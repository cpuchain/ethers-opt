import { TASK_COMPILE } from 'hardhat/builtin-tasks/task-names.js';
import { task, extendConfig } from 'hardhat/config.js';
import path from 'path';
import { access, constants, rm, mkdir, writeFile, readFile } from 'fs/promises';
import { glob } from 'glob';

async function checkAccess(dir) {
  try {
    await access(dir, constants.W_OK);
    return true;
  } catch {
    return false;
  }
}

async function flattenAll(taskArgs, hre) {
  const input = taskArgs?.input || "./contracts";
  const output = taskArgs?.output || "./flatten";
  const files = await glob(`${input}/**/*.sol`, { ignore: "node_modules/**" });
  await rm(output, { recursive: true, force: true });
  for (const file of files) {
    const { dir, base } = path.parse(file);
    const destDir = dir.replace(path.parse(input).base, path.parse(output).base);
    const dest = path.join(destDir, base);
    if (!await checkAccess(destDir)) {
      await mkdir(destDir, { recursive: true });
    }
    try {
      const flatten = await hre?.run("flatten:get-flattened-sources", { files: [file] });
      await writeFile(dest, flatten);
      console.log(`flatten:all: ${dest}`);
    } catch (e) {
      console.log(`flatten:all: error for ${dest} (likely circular)`);
      console.log(e);
    }
  }
}
task("flatten:all", "Flatten all contracts under flatten directory").addParam("input", "Contract src (default to contracts)", "./contracts").addParam("output", "Directory to save flatten contracts (default to flatten)", "./flatten").setAction(async (taskArgs, hre) => {
  await flattenAll(taskArgs, hre);
});

const importLineRegex = /^.*from\s+(['"])(\.[^'"]*?)(?<!\.[jt]s|\.json)\1.*$/gm;
async function typechainFix(taskArgs, hre) {
  const dir = taskArgs?.dir || hre?.config?.typechain?.outDir || "./typechain-types";
  console.log(`typechain:fix: scanning type files from ${dir}`);
  const files = await glob(`${dir}/**/*.ts`, { ignore: "node_modules/**" });
  for (const file of files) {
    let context = await readFile(file, { encoding: "utf8" });
    if (context.match(importLineRegex)) {
      console.log(`typechain:fix: fixed ${file}`);
      context = context.replace(
        /from\s+(['"])(\.[^'"]*?)(?<!\.[jt]s|\.json)\1/g,
        "from$1$2/index.js$1"
      );
    }
    await writeFile(file, context);
  }
}
task("typechain:fix", "Fix Typechain definitions for ESM generated by Hardhat").addParam("dir", "Typechain Directory", "").setAction(async (taskArgs, hre) => {
  await typechainFix(taskArgs, hre);
});

const DEFAULT_ETHERS_OPT_CONFIG = {
  flattenAll: false,
  typechainFix: false
};
extendConfig((config, userConfig) => {
  config.ethersOpt = [userConfig.ethersOpt].flat().map((el) => {
    const conf = Object.assign({}, DEFAULT_ETHERS_OPT_CONFIG, el);
    return conf;
  });
});
task(TASK_COMPILE).setAction(async (args, hre, runSuper) => {
  await runSuper();
  if (!hre.__SOLIDITY_COVERAGE_RUNNING) {
    const configs = hre.config.ethersOpt;
    await Promise.all(
      configs.map(async (config) => {
        if (config.flattenAll) {
          await flattenAll(
            {
              input: config.flattenInput,
              output: config.flattenOutput
            },
            hre
          );
        }
        if (config.typechainFix) {
          await typechainFix(
            {
              dir: config.typechainOutput
            },
            hre
          );
        }
      })
    );
  }
});
